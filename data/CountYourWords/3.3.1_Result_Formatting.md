# Result Formatting

### Result Formatting

The `Result Formatting` section describes how the word count results are formatted for display. The primary goal is to ensure that the output is clear, consistent, and easy to understand.

#### Output Structure

The result of a word count operation is typically structured as a `Pair` object, where the first element represents the total number of words and the second element is a `HashMap` containing the frequency of each word. This structure allows for both a summary statistic and detailed breakdown of the word distribution.

```java
public class Pair {
    private int first;
    private HashMap<String, Integer> second;

    public Pair(int first, HashMap<String, Integer> second) {
        this.first = first;
        this.second = second;
    }

    // Getters and setters
}
```

#### Formatting Rules

1. **Total Word Count**: The total word count is displayed at the top of the output.
2. **Word Frequency Table**: A table is generated to show each unique word along with its frequency.

#### Example Output

Given a file with the following content:

```
Hello world
This is a test.
World of Java!
```

The output might look like this:

```plaintext
Total Words: 9

| Word   | Frequency |
|--------|-----------|
| hello  | 1         |
| world  | 2         |
| this   | 1         |
| is     | 1         |
| a      | 1         |
| test   | 1         |
| of     | 1         |
| java   | 1         |
```

#### Code Implementation

The `CountYourWords` class contains the logic to perform the word count and format the output. Below is an example implementation:

```java
public class CountYourWords {
    public static Pair count(ArrayList<String> fileLines) {
        int totalWords = 0;
        HashMap<String, Integer> wordCounts = new HashMap<>();

        for (String line : fileLines) {
            String[] words = line.split("\\s+");
            totalWords += words.length;

            for (String word : words) {
                word = word.toLowerCase().replaceAll("[^a-z0-9]", "");
                if (!word.isEmpty()) {
                    wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
                }
            }
        }

        return new Pair(totalWords, wordCounts);
    }
}
```

#### Testing

To ensure the formatting is correct, unit tests are provided. Below is an example test case:

```java
public class CountYourWordsTest {
    @Test
    public void testMultipleLines() {
        ArrayList<String> fileLines = new ArrayList<>();
        fileLines.add("Hello world");
        fileLines.add("This is a test.");
        fileLines.add("World of Java!");

        Pair result = CountYourWords.count(fileLines);

        assertEquals(9, result.getFirst());

        HashMap<String, Integer> expectedCounts = new HashMap<>();
        expectedCounts.put("hello", 1);
        expectedCounts.put("world", 2);
        expectedCounts.put("this", 1);
        expectedCounts.put("is", 1);
        expectedCounts.put("a", 1);
        expectedCounts.put("test", 1);
        expectedCounts.put("of", 1);
        expectedCounts.put("java", 1);

        assertEquals(expectedCounts, result.getSecond());
    }
}
```

#### Mermaid Diagram

To visualize the flow of data through the `CountYourWords` class, a Mermaid diagram can be used:

```mermaid
graph TD;
    A[Input: ArrayList<String> fileLines] --> B{Split lines into words};
    B -- Word count --> C[Initialize totalWords = 0];
    B -- Word frequency --> D[Initialize wordCounts = new HashMap()];
    C --> E[Increment totalWords by number of words in line];
    D --> F[For each word: Convert to lowercase, remove non-alphanumeric characters, and update wordCounts];
    E --> G{Next line};
    G -- Yes --> B;
    G -- No --> H[Return Pair(totalWords, wordCounts)];
```

This diagram shows the high-level flow of data through the `CountYourWords` class, from input to output.