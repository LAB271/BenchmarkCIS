# Word Counting

## Word Counting

The `CountYourWords` system is designed to count words in a given text input. This process involves several key steps, including tokenization, normalization, and counting. Below, we will delve into the details of how these steps are implemented within the system.

### Tokenization

Tokenization is the first step in word counting. It involves breaking down the input text into individual words or tokens. The `CountYourWords` system uses a simple regular expression to identify words:

```java
// src/main/CountYourWords.java
public static List<String> tokenize(String text) {
    return Arrays.asList(text.split("\\W+"));
}
```

This method splits the input text using any non-word character (`\\W+`) as the delimiter. The resulting list of tokens is then returned.

### Normalization

Normalization involves converting all words to a consistent case (typically lowercase) to ensure that word counts are case-insensitive. This step helps in accurately counting occurrences of the same word regardless of its case:

```java
// src/main/CountYourWords.java
public static List<String> normalize(List<String> tokens) {
    return tokens.stream()
                 .map(String::toLowerCase)
                 .collect(Collectors.toList());
}
```

The `normalize` method takes a list of tokens and converts each token to lowercase using the `String.toLowerCase()` method. The resulting normalized list is then returned.

### Counting

The counting step involves iterating over the normalized list of words and keeping track of their occurrences. This can be efficiently done using a `HashMap`:

```java
// src/main/CountYourWords.java
public static Map<String, Integer> count(List<String> tokens) {
    Map<String, Integer> wordCounts = new HashMap<>();
    for (String token : tokens) {
        wordCounts.put(token, wordCounts.getOrDefault(token, 0) + 1);
    }
    return wordCounts;
}
```

The `count` method takes a list of normalized tokens and iterates over each token. For each token, it updates the count in the `wordCounts` map using the `getOrDefault` method to handle cases where the token is not yet present in the map.

### Edge Cases

Handling edge cases is crucial for robust word counting. Some common edge cases include:

1. **Empty Input:** If the input text is empty, the system should return a count of 0.
2. **Punctuation:** Punctuation marks should be ignored when counting words. For example, "hello," and "hello" should both be counted as "hello".
3. **Case Insensitivity:** The word counting should be case-insensitive, so "Hello" and "hello" should be treated as the same word.

The provided test cases in `CountYourWordsTest.java` cover these edge cases:

```java
// src/test/CountYourWordsTest.java
@Test
public void testEmptyFile() {
    ArrayList<String> fileLines = new ArrayList<>();
    Pair result = CountYourWords.count(fileLines);
    
    assertEquals(0, result.getFirst());
    assertTrue(result.getSecond().isEmpty());
}

@Test
public void testPunctuation() {
    ArrayList<String> fileLines = new ArrayList<>();
    fileLines.add("Hello, world!! Welcome to Java.");
    
    Pair result = CountYourWords.count(fileLines);
    
    assertEquals(5, result.getFirst());
    
    HashMap<String, Integer> expectedCounts = new HashMap<>();
    expectedCounts.put("hello", 1);
    expectedCounts.put("world", 1);
    expectedCounts.put("welcome", 1);
    expectedCounts.put("to", 1);
    expectedCounts.put("java", 1);
    
    assertEquals(expectedCounts, result.getSecond());
}

@Test
public void testCaseInsensitivity() {
    ArrayList<String> fileLines = new ArrayList<>();
    fileLines.add("Apple apple APPLE ApPlE");
    
    Pair result = CountYourWords.count(fileLines);
    
    assertEquals(4, result.getFirst());
    
    HashMap<String, Integer> expectedCounts = new HashMap<>();
    expectedCounts.put("apple", 4);
    
    assertEquals(expectedCounts, result.getSecond());
}
```

These test cases ensure that the word counting system handles various edge cases correctly.

### Performance Considerations

For large text inputs, performance can be a concern. The current implementation uses a simple `HashMap` for counting, which has an average time complexity of O(1) for insertions and lookups. However, for very large inputs, this could become a bottleneck.

To improve performance, the system could use more advanced data structures or parallel processing techniques. For example, using a concurrent hash map (`ConcurrentHashMap`) or distributing the counting task across multiple threads could help handle larger inputs more efficiently.

### Conclusion

The `CountYourWords` system provides a robust solution for counting words in text input. By breaking down the process into tokenization, normalization, and counting, the system ensures accurate word counts while handling various edge cases. The provided test cases validate the correctness of the implementation, and further performance optimizations can be considered for larger inputs.

For more detailed information on the `CountYourWords` project, refer to the [project's README file](https://github.com/yourusername/count-your-words/blob/main/readme.md).